I fully mocked the object graph, and then got an error:
Unnecessary stubbing. Please remove the unnecessary stabbing or use lenient().

So added lenient like so:
lenient().when(someDTO.getTypeCode()).thenReturn("1");

Then it got back to the previous error: 
NullPointer Cannot invoke "String.equals(Object)" because the return value of "someDTO.getTypeCode" is null.

What comes into my mind is that "the nested objects may have been detached" during the actuall runtime.

Previously, you guessed that something like this is going on inside the code:
for (SomeDTO child : parentDTO.getAnotherDTO().getSomeDTOList()) {
    if (child.getTypeCode().equals("1")) { ... }
}

However, that is not the case. 
In reality, they are separately initialized like this:

List<SomeDTO> someDTOs = parentDTO.getAnotherDTO().getSomeDTOList();
SomeDTO someDTO = someDTOs.get(0);

if(someDTO.getTypeCode().equals("1")) {
  // Do something
}

Does this structure seem to be the culprit?
